import (
  summaryWriter "summary_writer"
  mnistFormat   "mnist_data"
  lenet         "lenet"

  tf            "tensorflow:"
  nn            "tensorflow:nn"
  summary       "tensorflow:summary"
  train         "tensorflow:train"
)

func trainNn[fn, learningRate] {
  nao.var_transform[
    fn: func(data float, label double <?,10>, step int32) {
      fn(data) -- prediction
      nn.softmax_cross_entropy_with_logits(logits: ^, labels: label) -- xEntropy
      // tf.reduce_mean(xEntropy) -- xEntropy
      // summary.scalar(^) -- crossEntropy
      // summaryWriter.AddWithStep(^, step)

      tf.argmax(prediction, 1) == tf.argmax(label, 1) -- correct_prediction
      tf.reduce_mean(tf.cast(^, tf.float32))
      summary.scalar(^) -- accuracy
      summaryWriter.AddWithStep(^, step)

      emit w = after __leaves { tf.reduce_mean(xEntropy) }
    },
    macro: func [output, trainable] {
      let opt = train.GradientDescentOptimizer[learning_rate: learningRate]()
      opt:minimize[var_list: trainable, loss: output]()
      emit t = ^
    },
  ]()
  emit e = ^
}

func Train() {
  let imagesFile = "../MNIST_data/train-images-idx3-ubyte.gz"
  let labelsFile = "../MNIST_data/train-labels-idx1-ubyte.gz"

  // Load images file
  mnistFormat.ReadImages(imagesFile) -- allImages
  mnistFormat.ReadLabels(labelsFile) -- allLabels

  // Make new queue, add mnist data to it.
  let q = tf.RandomShuffleQueue[
    capacity: 60000,
    min_after_dequeue: 0,
    dtypes: {tf.float64, tf.float32},
    shapes: {<10>, <784>},
  ]()

  let qRef = q:queue_ref
  nao.enqueue_many(qRef, {allLabels, allImages})

  let trainStep = trainNn[fn: lenet.LeNet, learningRate: 0.01]

  let maxSteps = 400
  let f = for let step int32 <> = 0; step < maxSteps {
    let batchSize = 100

    let v = nao.dequeue_many[component_types: {tf.float64, tf.float32}](qRef, batchSize)

    let labels = v:0
    tf.reshape(v:1, [-1, 28, 28, 1]) -- images

    trainStep(images, labels, step) -- reducedMean

    summaryWriter.Debug(reducedMean)

    <- step = after __leaves { step + 1 }
  }

  tf.Assert(f:step == maxSteps, {"f:step == maxSteps"})

  ← result = after __leaves { 1 }
}
